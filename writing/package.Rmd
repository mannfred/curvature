---
title: "kyokusen"
author:
date: ""
output: 
  html_document:
  number_sections: no
  theme: flatly
  # pdf_document:
  #   latex_engine: xelatex
bibliography: curvature_review.bib
csl: cell.csl
link-citations: true #'yes' for html, 'true' for pdfs
linkcolor: blue
urlcolor: blue
citecolor: blue
---

#ethos

https://stackoverflow.com/questions/23232791/is-it-a-good-practice-to-call-functions-in-a-package-via 
If you frequently find yourself using just one function from another package, you can copy the code and add it to your own package. For example, I have a package for personal use that borrows %nin% from the Hmisc package because I think it's a great function, but I don't often use anything else from Hmisc. With roxygen2, it's easy to add @author and @references to properly attribute the code for a borrowed function. Also make sure the package licenses are compatible when doing this.




#sanity test: using the gradient and hessian to compute k on the unit circle 

Using the canonical definition of curvature (the inverse radius), the curvature of a unit circle is 1 at all points (1/r = 1/1 = 1). We created a function for a partial (half??) cirlce for x={0,0.9999}: circlefun<-function(x) (1-(x^2))^0.5. Because the radius is 1, the segment 

```
x<-seq(0, 0.9999, by=0.0001) 

circlefun<-function(x) (1-(x^2))^0.5 #unit circle: 1= x^2 + y^2 

dfun2<- deriv3(fun2form(function(x) (1-(x^2))^0.5), "x", func=TRUE)
param_fun<-function(t) c((1-(t^2))^0.5, t)
fun<-function(x) (1-(x^2))^0.5

gr2 <- attr(dfun2(x), "gradient") #computes 1st derivative bw x=0 to x=1

he2 <- attr(dfun2(x), "hessian")[ , , "x"] #computes 2nd derivative bw x=0 to x=1


k2 <- abs(he2)/(1 + gr2^2)^(3/2)
(sum(k2) * 0.0001) #*(180/pi)
```
#curvature()

run trace(fun2form, edit=TRUE) and change width.cutoff to 500L under deparse()
poly_list parameter filled by dorsalcurv_lst

```
totalK_fun<-function (x_range, poly_list, subdiv) 
{
  stopifnot(is.atomic(x_range)) # is.atomic checks that x.range cannot be a list or expression
  if (!is.numeric(x_range)) 
    stop("'x_range' must be a numeric vector!")
  if (length(x_range) != 2) 
    stop("'x_range' must be a vector of length two!")
  if (diff(x_range) < 0) #calculates the difference between x1 and x2 to ensure it's >0
    stop("please reorder 'x_range'.")
  # if (!inherits(fun, "function")) 
  #   stop("'fun' must be a 'function' of x!")
  
  # dfun <- deriv3(fun2form(fun), "x", func = TRUE) #func=TRUE returns a function
  
  exp_list <- lapply(poly_list, f) #a list of polynomial expressions to be read by deriv3()
  dfun <- deriv3(exp_list, "x", func=TRUE) %>% unname()
  
  if (attr(dfun(x_range[1]), "gradient") == attr(dfun(x_range[2]), "gradient"))  #make sure function is not a straight line
    stop("'fun' should not be a linear function of x!") 
  
  iter<- seq(0, 1, by=1/subdiv) #create vector of subdivisions to calculate arclength parameter
  arcfun_lst<- list() #empty bin
  b<- arclength(param_fun, x_range[1], x_range[2])$length #arc length of t-parameterized function
  
  for(i in seq_along(iter)){ 
    arcfun_lst[[i]] <- 
      local({
        b_sub<-iter[i]*b
        function(u) arclength(param_fun, x_range[1], u)$length - b_sub
      }) 
  }
  
  root_find<- function(x) uniroot(x, x_range)$root #root-finding function
  
  x <- sapply(arcfun_lst, root_find) #find roots for a list of 
  y <- func_lst(x) 
  gr <- attr(dfun(x), "gradient") #the tangents (first derv) of the x_n components, dfun() is defined above. The gradient matrix has elements that are the first deriv of a function
  he <- attr(dfun(x), "hessian")[, , "x"] # x is in the third dimension of this object (df?). The hessian matrix has elements that are the second deriv of a function
  k <- abs(he)/(1 + gr^2)^(3/2) #has n=subdiv measurements of k
  k_total<-(sum(k) /subdiv) *(180/pi) #add all measurements of k, rescale depending on #of subdivisions, and convert from rad to degrees
}

```
